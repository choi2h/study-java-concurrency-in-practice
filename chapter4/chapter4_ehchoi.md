## 4장 객체 구성

  

컴포넌트의 스레드 안전성을 안정적으로 확보할 수 있고, 이와 함께 개발자가 코드를 작성하는 과정에서 실수를 한다 해도 스레드 안전성을 해치지 않도록 도와주는 클래스 구성 방법을 살펴보자.

<br/>

## 4.1 스레드 안전한 클래스 설계

  

- 프로그램에서 사용하는 모든 값을 public static변수에 저장한다 해도 스레드 동기화가 맞춰진 프로그램을 작성할 수는 있다.

    - 구조적인 캡슐화 없이 만들어 낸 결과물을 여러 스래드에서 사용해도 안전한지를 확인하기 어렵다.
    - 객체를 나중에 변경해야 할 필요가 있을 때에도 스레드 동기화 문제 없이 변경하기란 더 어렵다.

- 클래스가 스레드 안전성을 확보하도록 설계하고자 할 때에는 다음과 같은 세가지를 고려해야 한다.

    - 객체의 상태를 보관하는 변수가 어떤 것인가?
    - 객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가?
    - 객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책

<br/>  

> 객체가 가질 수 있는 값의 범위와 변동 폭을 정확하게 인식하지 못한다면, 스레드 안전성을 완벽하게 확보할 수 없다. 클래스의 상태가 정상적이라는 여러 가지 제약 조건이 있을 때 클래스의 상태를 정상적으로 유지하려면 여러 가지 추가적인 동기화 기법을 적용하거나 상태 변수를 클래스 내부에 적절히 숨겨야 한다.

 <br/>

### 상태 의존 연산

- 특정 객체는 상태 기반으로 하는 `선행 조건`을 갖기도 한다.
- 상태 의존 연산 : 현재 조건에 따라 동작 여부가 결정되는 연산
- wait과 notify명령은 본질적으로 락을 사용하는 것과 굉장히 밀접한 관련이 있다.  
    - 특정 상태가 원하는 조건이 다다를 때까지 효율적으로 기다릴 수 있다.   
    - 올바르게 사용하기 쉽지 않다.
- 선행조건이 필요한 프로그램을 구현하고자 하는 경우
    - 세마포어나 블로킹 큐와 같은 라이브러리를 사용하는 편이 훨씬 간단하고 안전하다.

  
<br/>
  

### 상태 소유권

- 변수를 통해 객체의 상태를 정의하고자 할 때에는 해당 객체가 실제로 `소유하는 데이터`만 기준으로 삼아야 한다. 
- 대부분의 경우 소유권과 캡슐화 정책은 함께 고려하는 경우가 많다. 
    - 캡슐화 정책은 내부에 객체와 함께 상태 정보를 숨기기 때문에 객체의 상태에 대한 소유권이 있다. 
    - 특정 변수의 상태가 올바르게 유지되도록 조절하는 락 구조가 어떻게 움직이는지 대해서도 소유권을 갖는다. 
- 객체를 공개하면 그저 `공동 소유권` 정도를 가질 뿐 통제권을 갖는다 할 수는 없다.
    - 클래스는 일반 메소드나 생성 메소드로 넘겨받은 객체에 대한 소유권을 갖지 않는다.
    - 그러나 메소드를 특별하게 작성하면 소유권을 확보할 수도 있다. : 팩토리 메소드
- 컬렉션 클래스에서는 `소유권 분리` 형태를 사용하는 경우도 많다.
    - 컬렉션 내부의 구조에 대한 소유권 : 컬렉션 클래스
    - 컬렉션에 추가되어 있는 객체에 대한 소유권 : 클라이언트 프로그램

  
<br/>
<br/>

## 4.2 인스턴스 한정

- 객체를 적절하게 캡슐화하는 것으로도 스레드 안전성을 확보할 수 있다. : `한정` , `인스턴스 한정 기법`
- 특정 객체가 다른 객체 내부에 완벽하게 숨겨져 있다면 해당 객체를 활용하는 모든 방법을 한눈에 확실하게 파악할 수 있다.
- 객체 외부에서도 사용할 수 있는 상황보다 훨씬 간편하게 스레드 안전성을 분석해 볼 수 있다.

  

> 데이터를 객체 내부에 캡슐화해 숨겨진 내용은 해당 객체의 메소드에서만 사용할 수 있기 때문에 숨겨진 데이터를 사용하고자 할 때에는 항상 지정된 형태의 락이 적용되는지 쉽고 정확하게 파악할 수 있다.

  

- 객체 내부에서 사용할 목적으로 한정되어 있는 데이터는 사용 범위 밖으로 유출되면 안된다.
- 범위가 다르다 해도 한정된 객체는 제한된 범위를 벗어나서는 안된다. 
    - 개발자가 충분히 주의를 기울여야 한다.

<br/>
  
### 인스턴스 한정 기법

- 클래스를 구현할 때 스레드 안전성을 확보할 수 있는 가장 쉬운 방법이라고 해도 무리가 없다.
- 동기화를 위해 락을 적용하는 방법도 마음대로 선택할 수 있다. 
- 클래스 내부의 여러 가지 데이터를 여러 개의 락을 사용해 따로 동기화시킬 수 있다.
- 자바 플랫폼의 클래스 라이브러리를 보면 인스턴스 한정 기법을 사용하는 예를 여럿 찾아 볼 수 있다.  
    - 스레드에 안전하지 않은 ArrayList나 HashMap 등을 멀티스레드 환경에 안전하게 사용할 수 있도록 `Collections.synchronizedList`와 같은 팩토리 메소드가 존재한다.
- 이런 팩토리 메소드는 컬렉션의 기본 클래스에 스레드 안전성을 확보하는 방법으로 대부분 `데코레이터 패턴`을 활용한다.
- 이런 팩토리 메소드의 결과로 만들어진 래퍼 클래스는 기본 클래스의 메소드를 호출하는 연동 역할만 하면서 그와 동시에 모든 메소드가 동기화되어 있다. 
- 래퍼 클래스를 거쳐야만 원래 컬렉션 클래스의 내용을 사용할 수 있기 때문에 래퍼 클래스는 스레드 안전성을 확보할 수 있다.
- **자바 API문서에서도 보면 스레드 안전성을 제대로 확보하려면 래퍼 클래스를 통하지 않고 원래 객체에 직접 접근해 사용하는 일은 없어야 한다고 설명하고 있다.**

  

> 인스턴스 한정 기법을 사용하면 전체 프로그램을 다 뒤져보지 않고도 스레드 안전성을 확보하고 있는지 쉽게 분석해 볼 수 있기 때문에 스레드에 안전한 객체를 좀 더 쉽게구현할 수 있다.

  <br/>

### 자바 모니터 패턴

- 자바 모니터 패턴을 따르는 객체는 변경 가능한 데이터를 모두 객체 내부에 숨긴 다음 객체의 암묵적인 락으로 데이터에 대한 동시 접근을 막는다.
- 자바 모니터 패턴을 사용하는 라이브러리 클래스 : Vector, Hashtable
- 가장 큰 장점은 간결함이다.
- 단순한 관례에 불과하며 일정한 형태로 스레드 안전성을 확보할 수 만 있다면 어떤 형태의 락을 사용해도 무방하다.

```java
public class PrivateLock {
  pirvate final Object myLock = new Object();
  @GuardedBy("myLock") Widget widget;

  void someMethod(
) {
     synchronized(myLock) {
        //widget 변수의 값을 읽거나 변경
     }
  }
}
```

  

- 객체의 암묵적인 락을 사용하기 보다는 위처럼 락으로 활용하기 위한 private 객체를 준비해 두면 여러가지 장점을 얻을 수 있다.
- private으로 선언되기 때문에 외부에서는 전혀 건들 수 없다.

<br/>
<br/>

## 4.3 스레드 안전성 위임

- AtomicLong와 같은 객체 사용
    - 스레드 안전성 문제를 `위임` 하는 행위
- 아주 간단한 몇 가지 객체를 제외하고는 대부분의 객체가 둘 이상의 객체를 조합해 사용하는 합성 객체이다. 

<br/>

### 독립 상태 변수

- 스레드 안전한 변수 하나에만 스레드 안전성을 위임
- 위임하고자 하는 내부 변수가 두 개 이상이라 해도 두 개 이상의 변수가 서로 ‘독립적'이라면 클래스의 스레드 안전성을 위임할 수 있다.
- 독립적? 변수가 서로의 상태 값에 대한 연관성이 없다.

<br/>

### 위임할 때의 문제점

- 두 개 이상의 변수를 사용하는 복합 연산 메소드를 갖고 있다면 위임 기법만으로는 스레드 안전성을 확보할 수 없다.
- 이런 경우에는 내부적으로 락을 활용해서 `복합 연산이 단일 연산으로 처리되도록` 동기화해야 한다.
- 스레드 안전성을 내부 변수에게 모두 위임할 수 있는 상태  
    - 클래스가 서로 의존성이 없이 독립이다.  
    - 스레드 안전한 두 개 이상의 클래스를 조합해 만들어졌다.  
    - 두 개 이상의 클래스를 한번에 처리하는 복합 연산 메소드가 없다.

 <br/> 

### 내부 상태 변수를 외부에 공개

- 외부에 공개해도 안전한 변수
    - 상태 변수가 스레드 안전  
    - 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않다.  
    - 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다.


```java
public class SafePoint {

    private int x,y;

    private SafePoint(int[] a) {
        this(a[0], a[1]);
    }

    private SafePoint(SafePoint p) {
        this(p.get());
    }

    public SafePoint(int x, int y) {
         this.set(x, y);
    }

    public synchronized int[] get() {
        return new int[] {x, y};
    }

    public synchronized void set(int x, int y ) {
        this.x = x;
        this.y = y;
    }
}

```

- 위처럼 x와 y의 값을 한번에 get하고 set한다면 하나의 값만 바뀌어서 응답하게 되는 상황이 발생하지 않는다. 
- 이처럼 스레드 안전성을 해치지 않으면서 클래스 내부의 변경 가능한 값을 외부에 공개하는 방법으로 차량 추적 프로그램을 구현할 수 있다.

<br/>
<br/>

## 4.4 스레드 안전하게 구현된 클래스에 기능 추가

- 유용한 자바의 기본 클래스 라이브러리 
- 현재 만들어져 있는 클래스를 사용하는게 대부분 적절한 방법이다.
- 장점
    - 개발에 필요한 시간과 자원 절약
    - 오류 발생 가능성 감소
    - 유지보수 비용 절감
- 단일 연산 하나를 기존 클래스에 추가하고자 한다면
    -  해당하는 단일 연산 메소드를 기존 클래스에 직접 추가하는 방법이 가장 안전하다. 
- 외부 라이브러리를 가져다 사용하는 경우
    - 라이브러리의 소스코드를 갖고 있지 않을 수 있다.
    - 소스 코드를 갖고 있다 해도 자유롭게 고쳐 쓰지못할 경우가 많다.
    - 이미 만들어져 있는 클래스의 동기화 정책을 정확하게 이해하고 추가하고자 하는 메소드도 정확한 방법으로 동기화 시켜야 한다.
- 기능을 추가하는 또 다른 방법 : 기존 클래스를 상속받는 방법
    - 기존 클래스를 외부에서 상속받아 사용할 수 있도록 설계했을 때나 사용할 수 있다.
- 기존 클래스를 상속받아 기능을 추가하는 방법은 기존 클래스에 직접 기능을 추가하는 방법보다 문제가 생길 위험이 훨씬 많다. 
- 동기화를 맞춰야 할 대상이 두 개 이상의 클래스에 걸쳐 분산되기 때문이다.

<br/>  

### 호출하는 측의 동기화

- 클래스를 상속받지 않고도 클래스에 원하는 기능을 추가할 수 있는 세 번째 방법
- `도우미 클래스를 따로 구현`해서 추가 기능을 구현하는 방법
- 제3의 도우미 클래스를 만들어서 사용하려는 방법을 올바르게 구현 하려면 클라이언트 측 락이나 외부 락을 사용해 List가 사용하는 것과 동일한 락을 사용해야 한다.

<br/> 

### 클래스 재구성

- 재구성 : 기존 클래스에 새로운 단일 연산을 추가하고자 할 때 좀 더 안전하게 사용할 수 있는 방법
- 인터페이스를 위임받아 메소드를 재구성한다.

<br/>
<br/>

## 4.5 동기화 정책 문서화 하기

- 동기화 정책에 대한 내용을 문서로 남기는 일은 스레드 안정성을 관리하는데 가장 강력한 방법 중 하나다.
- 구현한 클래스가 어느 수준까지 스레드 안정성을 보장하는지에 대해 문서를 작성해둬야 한다.
    - 유지보수 팀이 원활하게 관리할 수 있다.
- 동기화 정책을 구성하고 결정할 때는 여러가지 사항을 고려해야 한다.  
    - 어떤 변수를 volatile로 할것인지?
    - 어떤 변수를 사용할 때 락으로 막아야 하는지?
    - 어떤 변수는 불변 클래스고 어떤 변수를 스레드에 한정시켜야 하는지?
    - 어떤 연산을 단일 연산으로 만들어야 하는지?
- 최소한 클래스가 스레드 안정성에 대해 어디까지 보장하는지 문서로 남겨야 한다.
- 직관적으로 봤을 때 `안전하겠다` 고 생각하는 클래스가 그렇지 않은 경우가 많다.
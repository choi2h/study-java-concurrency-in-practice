# 2장 스레드 안전성
스레드 안전성 : 데이터에 제어 없이 동시 접근하는 걸 막으려는 것

스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율해야 한다.

변경할 수 있는 하나의 상태 변수를 적절한 동기화 없이 접근하면 그 프로그램은 잘못된 것이다.  
이러한 잘못된 프로그램을 해결 방법에는 3가지가 있다.
- 해당 상태 변수를 스레드 간에 공유하지 않거나
- 해당 상태 변수를 변경할 수 없도록 만들거나
- 해당 상태 변수에 접근할 때 언제나 동기화를 사용한다.

스레드 안전성을 확보하기 위해 나주에 클래스를 고치는 것보다 애당초 스레드에 안전하게 설계하는 편이 훨씬 쉽다.   
객체 지향 프로그래밍 기법에서 사용하는 **캡슐화**나 **데이터 은닉** 같은 기법이 스레드에 안전한 클래스를 작성하는 데도 도움이 될 수 있다.  
프로그램 상태를 잘 캡슐화할수록 프로그램을 스레드에 안전하게 만들기 쉽고 유지보수팀에서도 역시 해당 프로그램이 계속해서 스레드에 안전하도록 유지하기 쉽다.

<br/>
<br/>

## 2.1 스레드 안전성이란?
스레드에 대한 납득할만한 정의의 핵심은 모두 정확성 개념과 관계가 있다.

**정확성?**  
클래스가 해당 클래스의 명세에 부합한다는 뜻으로 잘 작성된 클래스 명세는 객체 상태를 제약하는 불변조건과 연산 수행 후 효과를 기술하는 후조건을 정의한다.

여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어디에 끼워 넣든 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다. 그리고 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.

<br/>

### 2.1.1 예제 : 상태 없는 서블릿
상태 없는 객체에 접근하는 스레드가 어떤 일을 하든 다른 스레드가 수행하는 동작의 정확성에 영향을 끼칠 수 없기 때문에 상태 없는 객체는 항상 스레드 안전하다.

상태가 없는 객체?
- 선언한 변수가 없다.
- 다른 클래스의 변수를 참조하지 않는다.

-> 특정 계산을 위한 일시적인 상태는 스레드의 스택에 저장되는 지역 변수에만 저장하고, 실행하는 해당 스레드에서만 접근 가능하다.

만약 여러 요청 간에 뭔가를기억할 필요가 있을 때에야 스레드 안전성이 문제가 된다.

<br/>
<br/>

## 2.2 단일 연산



<br/>

### 2.2.1 경쟁조건
경쟁조건 : 타이밍이 안 좋을 때 결과가 잘못될 가능성으로 타이밍이 딱 맞았을 때만 정답을 얻는 경우를 말한다. 

경쟁 조건은 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실행하는 상황``에 따라 계산의 정확성이 달라질 때 나타난다.   
가장 일반적인 경쟁 조건 형태는 잠재적으로 유효하지 않은 값을 참조해서 다음에 뭘 할지를 결정하는 점검 후 행동 형태의 구문이다.

점검 후 행동 : 잠재적으로 유효하지 않은 관찰 결과로 결정을 내리거나 계산을 하는 것

어떤 사실을 확인하고 그 관찰에 기반해 행동을 하지만 해당 관찰은 관찰한 시각과 행동한 시각 사이에 더 이상 유효하지 않게 됐을 수도 있다.   
-> 대부분의 경쟁 조건은 관찰 결과의 무효화로 이어진다.

<br/>

### 2.2.2 늦은 초기화 시 경쟁 조건
점검 후 행동하는 흔한 프래그래밍 패턴으로 늦은 초기화가 있다.   
늦은 초기화 : 특정 객체가 실제 필요할 때까지 초기화를 미루고 동시에 단 한 번만 초기화되도록 하기 위한 것  
ex) 싱글톤 패턴

대부분 병렬 처리 오류가 그렇듯, 경쟁 조건 때문에 프로그램에 오류가 항상 발생하지는 않으며, 운 나쁘게 타임이이 꼬일 떄만 문제가 발생한다.   
하지만 경쟁 조건은 데이터의 일관성과 객체 유일성에 대한 제약이 깨지는 등 그 자체로 심각한 문제를 일으킬 수 있다.

<br/>

### 2.2.3 복합 동작
경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 하며, 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌 수정 이전이나 이후에만 상태를 읽거나 변경을 가할 수 있다. 

점검 후 행동과 읽고 수정하고 쓰기 같은 일련의 동작을 복합 동작이라고 하며, 스레드에 안전하기 위해서는 전체가 항상 단일 연산으로 실행돼야 한다.
> java.util.concurrent.atomic패키지에는 숫자나 객체 참조 값에 대해 상태를 단일 연산으로 변경할 수 있도록 단일 연산 변수 클래스가 준비돼 있다. 

가능하면 클래스 상태를 관리하기 위해 AtomicLong처럼 스레드에 안전하게 이미 만들어져 있는 객체를 사용하는 편이 좋다.  
스레드 안전하지 않은 상태 변수를 선언해두고 사용하는 것보다 이미 스레드 안전하게 만들어진 클래스가 가질 수 있는 가능한 상태의 변화를 파악하는 편이 훨씬 쉽고 스레드 안전성을 더 쉽게 유지하고 검증할 수 있다.

<br/>
<br/>

## 2.3 락
스레드 안전성의 정의에 따르면 여러 스레드에서 수행되는 작업의 타이밍이나 스케줄링에 따른 교차 실행과 관계 없이 불변조건이 유지돼야 스레드에 안전하다.  
여러 개의 변수가 하나의 불변조건을 구성하고 있다면, 이 변수들은 서로 독립적이지 않으며 한 변수의 값이 다른 변수에 들어갈 수 있는 값을 제한할 수 있게된다.  
따라서 변수 하나를 갱신할 때는, 다른 변수도 동일한 단일 연산 작업 내에서 함께 변경해야 한다.

> 상태를 일관성있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.

<br/>

### 2.3.1 암묵적인 락
자바에서는 단일 연산 특성을 보장하기 위해 synchronized라는 구문으로 사용할 수 있는 락을 제공한다.  
synchronized 구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성된다. 

```java
synchronized(lock) {
 //lock으로 보호된 공유 상태에 접근하거나 해당 상태를 수정한다.
}
````

모든 자바 객체는 락으로 사용할 수 있다. 자바에 내장된 락을 **암묵적인 락** 혹은 **모니터 락**이라고 한다.  
락은 스레드가 블록에 들어가기 전에 자동으로 확보되며 정상적으로든 예외가 발생해서든 해당 블록을 벗어날 때 자동으로 해제되며 해당 락으로 보호된 synchronized 블록이나 메소드에 들어가야만 암묵적인 락을 확보할 수 있다.


자바에서 암묵적인 락은 **뮤텍스** 또는 **mutual exclusion lock(상호배재락)**으로  동작한다.   
한 번에 한 스레드만 특정 락을 소유할 수 있으며 같은 락으로 보호되는 synchronized 서로 다른 블록 역시 서로 단일 연산으로 실행된다는 것이다.  
즉, 한 스레드가 synchronized블록을 실행 중이라면 같은 락으로 보호되는 synchronized 블록에 다른 스레드가 들어와 있을 수 없다.

단일 연산 특성 : 일련의 문장이 하나의 나눌 수 없는 단위로 실행되는 것처럼 보이는 것

<br/>

### 2.3.2 재진입성

재진입성 : 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것  
암묵적인 락은 재진입 가능하기 때문에 특정 스레드가 자기가 이미 획득한 락은 다시 확보할 수 있다.

재진입성을 구현 방법
1. 각 락마다 확보 횟수와 확보한 스레드를 연결시켜 둔다.
2. 스레드가 해제된 락을 확보하면 JVM이 락에 대한 소유 스레드를 기록하고 확보 횟수를 1로 지정한다. 
3. 같은 스레드가 락을 다시 얻으면 횟수를 증가시키고, 소유한 스레드가 synchronized 블록 밖으로 나가면 횟수를 감소시킨다. 
4. 이렇게 횟수가 0이되면 해당 락은 해제된다.

재진입성 때문에 락의 동작을 쉽게 캡슐화 할 수 있고, 객체 지향 병렬 프로그램을 개발하기가 단순해졌다. 재진입 가능한 락이 없으면 하위 클래스에서 synchronized메소드를 재정의하고 상위 클래스의 메소드를 호출하는 아래처럼 지극히 자연스러워 보이는 코드도 데드락에 빠질 것이다.

```java
public class Widget {
    public synchronized void doSomething() {
        ...
    }
}

public class LoggingWidget extends Widget {
    public synchronized void doSomeThing() {
        System.out.println(toString() + " : calling doSomething.");
        super.doSomething();
    }
}
```

<br/>
<br/>

## 2.4 락으로 상태 보호하기
락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 때문에, 공유된 상태에 배타적으로 접근할 수 있도록 보장하는 규칙을 만들 때 유용하다. 이런 절차를 정확하게 따르면 항상 일관적인 상태를 유지할 수 있다. 
- 특정 변수에 대한 접근을 조율하기 위해 동기화할 때는 해당 변수에 접근하는 모든 부분을 동기화해야 한다. 
- 변수에 대한 접근을 조율하기 위해 락을 사용할 땐 해당 변수에 접근하는 모든 곳에서 반드시 같은 락을 사용해야 한다.

모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 하며 유지보수하는 사람이 알 수 있게 어느 락으로 보호하고 있는지를 명확하게 표시하라.

락을 활용함에 있어 일반적인 사용 예는 먼저 모든 변경 가능한 변수를 객체 안에 캡슐화하고, 해당 객체의암묵적인 락을 사용해 캡슐화한 변수에 접근하는 모든 코드 경로를 동기화함으로써 여러 스레드가 동시에 접근하는 상태에서 내부 변수를 보호하는 방법이다. 이 때 객체의 상태를 나타내는 모든 변수는 객체의 암묵적인 락으로 보호된다. 

특정 변수가 락으로 보호되면, 한 번에 한 스레드만 해당 변수에 접근할 수 있다는 점을 보장할 수 있다.  
클래스에 여러 상태 변수에 대한 불변조건이 있으면 불변조건에 관련된 각 변수는 모두 같은 락으로 보호돼야 하며 이렇게 하면 관련된 모든 변수를 하나의 단일 연산 작업 내에서 접근하거나 갱신할 수 있다.

무차별적으로 synchronized를 적용하지는 말자.

<br/>
<br/> 

## 2.5 활동과 성능
Service메소드 전체를 동기화하면(synchronized키워드를 지정) 한 번에 한 스레드만 실행할 수 있게 된다.  
이는 동시에 여러 요청을 할 수 있게 설계된 서블릿 프레임웍의 의도와 배치되고, 요청이 많아졌을 경우 느린 속도 때문에 사용자 불만이 높아질 것이다. 
이런 방법으로 동작하는 웹 애플리케이션은 병렬 처리 능력이 떨어진다고 말한다. 즉 처리할 수 있는 동시 요청의 개수가 자원의 많고 적음이 아닌 애플리케이션 자체의 구조때문에 제약된다. 

synchronized 범위를 줄였을 때 장점
- 스레드 안전성 유지
- 동시성을 향상

그러나 락을 얻어 놓는 작업만으로도 어느 정도의 부하가 따르기 때문에 synchronized 블록을 너무 잘개 쪼개는 일은 바람직하지 않다.  
-> 단일연산으로 처리해야 하는 작업을 여러 개의 synchronized 블록으로 나누진 말아야 한다.


synchronized 블록의 크기를 적정하게 유지하려면 안전성, 단순성, 성능 등의 서로 상충하는 설계 원칙 사이에 적절한 타협이 필요할 수 있다.  
때론 단순성과 성능이 서로 상충되는데 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성을 희생하고픈 유혹을 버려야 한다.

또한, 락을 사용할 땐 브록 안의 코드가 무엇을 하는지, 수행하는 데 얼마나 걸릴지를 파악해야 한다.  
계산량이 많은 작업을 하거나 잠재적으로 대기 상태에 들어갈 수 있는 작업을 하느라 락을 오래 잡고 있으면 활동성이나 성능 문제를 야기할 수 있다.  
-> 복잡하고 오래 걸리는 계산  작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을수 있는 작업을 하는 부분에서는 가능한 락을 잡지 마라.


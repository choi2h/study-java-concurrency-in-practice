# 1장 개요

<br/>

### 프로세스

각자가 서로 격리된 채로 독립적으로 실행되는 프로그램으로서 운영체제는 프로세스마다 메모리, 파일 핸들, 보안 권한 등의 자원을 할당한다.

프로세스끼리는 서로 통신을 할 수도 있는데 소켓, 시그널 핸들러, 공유 메모리, 세마포어, 파일 등의 비교적 큰 단위의 다양한 통신 수단이 제공된다.

  <br/>

### 프로그램을 동시에 실행할 수 있는 운영체제를 개발하게 된 요인

- 자원 활용  
    프로그램은 외부 동작이 끝나기를 기다려야 하는 경우가 많은데, 기다리는 동안은 유용한 일을 처리하지 못한다.  
    따라서 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 편이 더 효율적이다.
- 공정성  
    여러 사용자와 프로그램이 컴퓨터 내 자원에 대해 동일한 권한을 가질 수 있다.  
    한 번에 프로그램 하나가 끝날때까지 대기하고 교체하는 것보다는 더 작은 단위로 컴퓨터를 공유하는 방법이 바람직하다.
- 편의성  
    여러 작업을 전부 처리할 수 있는 프로그램 하나를 작성하는 것보다 각기 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율하는 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직하다.


<br/>
  
### 프로그램에서 스레드를 사용하면

- 한 프로세스 안에 여러 개의 프로그램 제어 흐름이 공존할 수 있다.
-  멀티프로세서 시스템에서 자연스럽게 하드웨어 병렬성을 이용할 수 있다. 
- 한 프로그램 내 여러 스레드를 동시에 여러 개의 CPU에 할당해 실행시킬 수 있다.  
    
  <br/>

### 프로세서 스케줄링의 기본 단위 : 스레드

제대로 설계만 한다면 활성 상태인 스레드가 여러 개의 프로그램은 여러 프로세서에서 동시에 실행될 수 있으므로 가용한 프로세서 자원을 더 효율적으로 이용해서 처리 속도를 높일 수가 있다.  만약, 프로그램이 스레드 하나로 구성되면 동기 I/O자업이 완료될 때까지 기다리는 동안 프로세서가 놀게 된다. 그러나 멀티스레드 프로그램에선 스레드 하나가 I/O가 끝나길 기다리는 동안 다른 스레드가 계속 실행될 수 있다.
  
<br/>
<br/>

## 스레드란?

### 스레드 (=가벼운 프로세스)

현대 운영체제의 대부분은 프로세스가 아니라 스레드를 기본 단위로 CPU 자원의 스케줄을 정한다.

 <br/> 

### 스레드 특징

- 하나의 스레드는 다른 스레드와 상관 없이 비동기적으로 실행된다.  
    
- 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유한다.  
    \=> 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 힙에 객체를 할당한다.  
    \=> 그러나, 공유된 데이터에 접근하는 과정을 적절하게 동기화하지 않으면 예상치 못한 결과를 얻을 수 있다.

- 각기 별도의 프로그램 카운터, 스택, 지역 변수를 갖는다.  
    
<br/>

### 스레드의 이점

- 개발 및 유지 보수 비용을 줄일 수 있다.
- 복잡한 애플리케이션의 성능을 향상시킬 수 있다.
- 비동기적인 일 흐름을 거의 순차적으로 바꿀수 있어 사람이 일하고 상호 작용하는 방식을 모델링하기 쉬워진다.
- GUI애플리케이션에서 사용자 인터페이스가 더 빨리 반응하게 만들기도 하고, 서버 애플리케이션에서 자원 활용도와 처리율을 높이는데 유용하다.
- JVM을 더 단순하게 구현할 수 있도록 도와주기도 한다.

 <br/> 

### 단순한 모델링

작업이 복잡하면 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다. 이런 작업 흐름에서는 특정한 동기화 시점에서만 상호 작용이 발생한다.

서블릿이나 RMI와 같은 프레임웍에서 종종 활용 된다.

프레임웍은 요청관리, 스레드 생성, 로드 밸런싱, 그리고 작업 흐름 내에서 적절한 시점에 적절한 애플리케이션 컴포넌트에게 요청을 분배하는 등의 상세한 뿐을 처리한다. 이 떄문에 컴포넌트 개발 작업이 훨씬 단순해지고 프레임웍을 쉽게 익힐 수 있다.

<br/>  

### 단순한 비동기 이벤트 처리

여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우  
→ 각 연결마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업이 쉬워진다.

지금까지의 운영체제는 하나의 프로세스가 생성할 수 있는 스레드 개수에 상대적으로 제약이 심해 최대 수백 개정도만을 생성할 수 있었다. 그러다 보니 표준 자바 API에서도 대기 상태에 들어가지 않는 I/O를 지원할 수 있도록 java.nio같은 패키지가 추가됐다. 하지만 시간이 지나면서 운영체제에서 더 많은 스레드를 지원할 수 있게 됨에 따라, 일부 플렛폼에서는 다수의 클라이언트에 대해서도 클라이언트마다 스레드를 하나씩 생성하는 일이 현실적인 경우가 많아지고 있다.

- 넌블로킹 I/O방법도 나름대로의 장점이 있지만 운영체제에서 다 많은 스레드를 지원할 수 있기 때문에 반드시 넌블로킹 I/O를 써야만 하는 경우는 더 줄었다.

<br/>
<br/> 

## 스레드 사용의 위험성

자바 자체에 스레드 관련 기능이 내장되어 있다는 점은 어떻게 보면 양날의 칼이라고 할 수 있다.

왜?
언어 및 라이브러리 측면에서의 스레드 자원과 플랫폼을 독립적으로 정형화 된 메모리 모델 때문에 병렬 프로그램을 개발하는 일이 쉽긴 하지만, 스레드를사용해 작성하는 프로그램이 더 많아졌기 떄문에 개발자에 대한 기대치도 높아지는 경향이 있다.

 <br/> 

### 개발자라면 대부분 스레드 안정성에 대해 잘 알아야 한다.

동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 순서가 예측하기 어려워진다. 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용중인 변수를 읽거나 수정할 수도 있게 된다. 이는 데이터가 예측 못한 시점에 변경되어 결과를 추론하기 어려워질 수 있다. 멀티 스레드 프로그램이 동작하는 모습을 예측하려면 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점을 적절하게 조율하거나 동기화를 해줘야 한다.

  
<br/>
<br/>  

## 동시 수행 코드를 개발할 때는 반드시 스레드 안정성 문제를 신경 써야 한다. 

단일 스레드 프로그램도 당연히 안정성과 정확성을 유지하도록 작성돼야 하지만,멀티스레드에서는 추가적인 안정성 위험이 생길 수 있으니 더 유의해야 한다.  

> 안정성 : 잘못된 일이 생기지 않는다.  
> 활동성 : 원하는 일이 결국 일어난다.

추가적인 안정성 위험
- 활동성 위험
    - 어떤 작업이 전혀 진전되지 못하는 상태에 빠질 때 → 무한반복문으로 인한 다음 코드 실행 불가  
    - ex) 데드락, 소모상태, 라이브락 등
    - 각기 다른 스레드에서 실행하는 작업의 상대적인 타이밍에 따라 활동성 문제점이 나타날 수 있다.  
    그러나 이는 테스트 도중에 잘 드러나지 않아 더 위험하다.

- 성능 문제
    - 성능 문제는 형편없는 서비스 시간, 반응성, 처리율, 자원 소모, 규모에 따른 확장성 등 넓은 범위의 문제들을 포괄한다.  
    - 스레드를 사용하면 실행 중에 어느 정도 부하가 생길 수 있다.  
        - 스레드가 많은 프로그램에서는 **컨텍스트 스위칭** 이 더 빈번하고, 그 때문에 상당한 부담이 생긴다.   
    - 컨텍스트 스위칭 시 일어나는 일
        - 실행중인 컨텍스트를 저장하고 다시 읽어들여야 한다.
        - 메모리를 읽고 쓰는데 있어 지역성이 손실된다.
        - 스레드를 실행하기도 버거운 CPU시간을 스케줄링하는 데 소모해야 한다.
        - 스레드가 데이터를 공유할 때는 동기화 수단도 사용해야 한다.
        - 이런 동기화는 컴파일러 최적화를 방해하고, 메모리 캐시를 지우거나 무효화 하기도 한다.

<br/>

## 스레드는 어디에나

프레임워크 때문에 프로그램이 병렬로 실행되는 경우가 생기면 병렬로 실행된다는 사실을 프레임워크 분만 아니라 프로그램에서도 인식하고 적절히 대응해야 한다.   

프레임워크에 의해 호출되는 컴포넌트만이 아닌 컴포넌트가 실행되는 과정에서 접근하는 코드 경로에 포함된 컴포넌트는 모두 마찬가지로 스레드에 안전해야 한다. 

컴포넌트는 언제나 프로그램 내부의 상태에 접근하기 때문에 해당 접근하는 모든 코드 경로에 해당하는 컴포넌트 역시 스레드 안전해야 한다.
Chapter 01
===========
# 1장 개요
  &nbsp;&nbsp;&nbsp;스레드는 자바 언어에서 피할 수 없는 특성이고, 복잡한 비동기 코드를 더 단순한 순차적 코드로 바꿔 복잡한 시스템을 단순하게 개발 할 수 있게 해주기 때문에, 작업을 동시에 실행하는 문제에 신경 써야 한다. 또한 스레드는 멀티프로세서 시스템의 능력을 최대한 끌어낼 수 있는 가장 쉬운 방법이다.
<br>
<br>

## 1.1 작업을 동시에 실행하는 일에 대한 간략한 역사
  &nbsp;&nbsp;&nbsp;운영체제는 여러 개의 프로그램을 각자의 프로세스 내에서 동시에 실행할 수 있도록 발전됐다. (프로세스: 각자가 서로 격리된 채로 독립적으로 실행되는 프로그램) 운영체제는 프로세스 마다 메모리, 파일 핸들, 보안 권한 등의 자원을 할당해준다.

여러 프로그램을 동시에 실행할 수 있는 운영체제를 개발하게 된 요인은 다음과 같다.
+ 자원 활용<br>
  프로그램이 입출력과 같이 외부 동작이 끝나기만을 기다리지 않고, 다른 프로그램을 실행하도록 지원하는것. 
+ 공정성<br>
  컴퓨터 내 자원을 하나의 프로그램이 독점해서 사용하는 것이 아닌, 작은 단위로 공유해서 여러 사용자와 프로그램이 동일한 권한을 가지도록 하는것. 
+ 편의성<br>
  여러 작업을 전부 처리하는 프로그램이 아닌, 각기 일을 하나씩 처리하고 필요할 때 프로그램 간 조율하는 프로그램을 여러 개 작성하는 것이 더 쉽다.

&nbsp;&nbsp;&nbsp;위와 같은 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안됐다. 

&nbsp;&nbsp;&nbsp;스레드로 인해 한 프로세스 안에 여러개의 프로그램 제어 흐름이 공존할 수 있다. 스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유하면서, 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 갖게 된다.

&nbsp;&nbsp;&nbsp;프로그램을 스레드로 분리하면 동시에 여러 개의 CPU에 할당에 실행 시키는것과 같은 멀티프로세서 시스템에서 하드웨어 병렬성을 이용할 수 있다.

&nbsp;&nbsp;&nbsp;스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 힙에 객체를 할당하기 때문에 프로세스 때보다 더 세밀한 단위로 데이터 공유가 가능하다. 다만 적절한 동기화가 없으면 다른 스레드가 사용 중인 변수를 변경하여 예상치 못한 결과가 나오기도 한다.
<br>
<br>

## 1.2 스레드의 이점
 &nbsp;&nbsp;&nbsp;스레드를 잘 사용하면 개발 및 유지 보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상시킬 수 있다.

### 1.2.1 멀티 프로세서 활용
 &nbsp;&nbsp;&nbsp;프로세서 스케줄링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다. 프로세서 두 개에 스레드 하나인 프로그램을 실행하면 CPU 자원의 50%를 낭비하며, 스레드가 여러 개인 프로그램은 여러 프로세서에서 동시에 실행 될 수 있다. 멀티스레드 프로그램은 가용한 프로세서 자원을 더 효율적으로 처리 속도를 높일 수 있다.

### 1.2.2 단순한 모델링
 &nbsp;&nbsp;&nbsp;한 종류의 일을 순차적으로 처리하는 프로그램은 작성도 쉽고 오류 적다. 스레드를 종류별 작업마다 할당하면 마치 순차적인 작업 처럼 처리 할 수 있어서 복잡하고 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름으로 나눌 수 있게 된다. 이런 작업 흐름에서는 특정한 동기화 시점에서만 상호 작용이 발생한다.<br>
 이런 장점은 서블릿servlet이나 RMI(Remote Method Invocation)와 같은 프레임워크에서 활용되며, 요청 관리, 스레드 생성, 로드 밸런싱, 작업 흐름 내 적절한 시점에 적절한 애플리케이션 컴포넌트에게 요청 분배하는 등의 상세한 부분을 처리하게 된다.

### 1.2.3 단순한 비동기 이벤트 처리
 &nbsp;&nbsp;&nbsp;여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우 각 연결마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업이 쉬워진다. 읽을 데이터를 대기하는 상태에 들어가도 다른 스레드가 요청을 처리하는 데에 영향을 끼치지 않는다.

### 1.2.4 더 빨리 반응하는 사용자 인터페이스
&nbsp;&nbsp;&nbsp;GUI 애플리케이션에서는 이벤트 전달 스레드를 사용하게 되면서 사용자 인터페이스 이벤트가 발생해도 코드가 ‘메인 이벤트 루프’를 통하지 않아도 애플리케이션이 정의한 이벤트 핸들러가 이벤트 전달 스레드에서 호출되어 처리한다.
<br>
<br>

## 1.3 스레드 사용의 위험성
&nbsp;&nbsp;&nbsp;자바에서의 언어 및 라이브러리 스레드 지원과 플랫폼 독립적으로 정형화 된 메모리 모델 때문에 병렬 프로그램을 개발하는 일이 쉬워지긴 했지만, 스레드를 사용해 작성하는 프로그램이 더 많아졌기 때문에 개발자는 스레드 안전성에 대해 잘 알아야 한다.

### 1.3.1 안전성 위해 요소
&nbsp;&nbsp;&nbsp;동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 숫자가 예측하기 어려워진다. 
아래의 예제는 스레드가 하나일 때는 아무런 문제가 없지만, 스레드가 여럿일 때는 제대로 동작하지 않는다.
```
@NotThreadSafe
public class UnsafeSequence { // 스레드 안전하지 않은 일련 번호 생성 프로그램
 private int value;
 
 public int getNext() {
  return value++;
 }
}
```
&nbsp;&nbsp;&nbsp;타이밍이 좋지 않은 시점에 두 개의 스레드가 getNext 메소드를 동시에 호출했을 때 같은 값이 나오는 의도하지 않은 동작을 할 가능성이 있다. 증가 연산자는 하나의 연산 같지만, 값을 읽고→ 읽은 값에 1을 더하고 → 결과를 기록하는 여러개의 단계로 나뉘어 있다. 다른 스레드가 끼어들 여지가 있는 것이다. 이러한 위험성은 경쟁 조건race condition이라는 예제로 볼 수 있다. (실행 과정에서 연산이 어떻게 서로를 간섭하느냐에 따라 결과가 달라짐)<br>
 
스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수 있는데, 이는 다른 스레드 간 통신 방식보다 데이터 공유가 쉬운 장점도 되지만 예측 못한 시점에 데이터가 변경되어 혼동을 일으킬 수 있는 단점도 된다.<br>
 멀티프로스레스 프로그램이 동작하는 모습을 예측하려면 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점에 동기화 수단을 사용해 접근을 조율해야 한다.
```
@ThreadSafe
public class Sequence { // 스레드 안전한 일련번호 생성 프로그램
 @GuardedBy("this") pricate int value;

 public synchronized int getNext() { // 동기화 사용
  return value++;
 }
}
```
&nbsp;&nbsp;&nbsp;동기화를 하지 않으면 컴파일러, 하드웨어, 실행 환경 각각에서 명령어의 실행 시점이나 실행 순서를 자유롭게 조정할 수 있으며 성능 향상에 도움이 되지만, 스레드 간에 데이터가 공유로 인해 프로그램에 오류가 발생하지 않도록 명확하게 구분해줘야 하는 부담을 안아야 한다.

### 1.3.2 활동성 위험
&nbsp;&nbsp;&nbsp;멀티 스레드 프로그램을 개발할 때 스레드 안전성과 정확성을 유지하고 신경 써야 한다. 단일 스레드 프로그램도 똑같이 신경써야 하지만 단일로 사용할때에는 나타나지 않는 추가적인 형태의 활동성liveness 장애가 생길 수 있다.<br>
&nbsp;&nbsp;&nbsp;안전성은 ‘잘못된 일이 생기지 않는다’이고, 활동성은 ‘원하는 일이 결국 일어난다’는 보완적인 목표에 관한 것이다. 어떤 작업이 전혀 진전되지 못하는 상태에 빠질 때 활동성 장애가 발생했다고 한다. 대표적인 예로는 무한 반복문을 만들어 다음에 놓인 코드가 절대 실행되지 않는 경우다.<br>
&nbsp;&nbsp;&nbsp;스레드를 사용하면 활동성 관련 문제의 위험성이 증가한다. 예를 들어 스레드 A에서 스레드 B가 독점하고 있는 자원을 기다리고 있는데 스레드 B가 해당 자원을 절대 놓지 않는다면, 스레드 A는 영영 기다리기만 한다. 활동성 장애 유형에는 데드락deadlock, 소모상태starvation, 라이브락livelock 등 이 있다. 활동성 장애를 일으키는 오류도 다른 오류와 같이 초기에 파악하기 어렵고 각기 다른 스레드에서 실행하는 작업의 상대적인 타이밍에 따라 문제점이 나타나기 때문에 개발이나 테스트 도중에 잘 드러나지 않는다.

### 1.3.3 성능 위험
 &nbsp;&nbsp;&nbsp;활동성과 함께 성능도 관련이 많은데 활동성이 좋은 반면 성능이 좋지 않는 경우도 있기 때문이다. 성능 문제는 형편없는 서비스 시간, 반응성, 처리율, 자원 소모, 규모에 따른 확장성 등 넓은 범위의 문제들을 포괄한다.<br>
 잘 설계된 병렬 프로그램은 성능을 향상 시킬 수 있지만, 실행 중에 어느 정도 부하가 생기기도 한다. 스레드가 많은 프로그램에서는 컨텍스트 스위칭(다른 스레드가 실행될 수 있게 스케줄러가 현재 실행 중인 스레드를 잠시 멈출 때)이 더 빈번하고, 이는 실행중인 컨텍스트를 저장하고 다시 읽어들여야 하며, 메모리를 읽고 쓰는 데 있어 지역성locality이 손실되고, 스레드를 실행하기도 버거운 CPU 시간을 스케줄링하는 데 소모해야 한다. <br>
 또 스레드가 데이터를 공유할 때는 동기화 수단도 사용해야 한다. 이런 동기화는 컴파일러 최적화를 방해하고, 메모리 캐시를 지우거나 무효화 하기도 한다. 그 밖에 공유 메모리 버스에 동기화 관련 트래픽을 유발하기도 한다.
<br>
<br>

## 1.4 스레드는 어디에나
&nbsp;&nbsp;&nbsp;프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임워크에서 스레드를 생성할 수도 있다. (자바 : main 메소드를 실행하는 주 스레드, 가비지 컬렉션, 객체 종료object finalization / AWT (Abstract Window Toolkit)와 스윙Swing : 사용자 인터페이스 프레임워크는 사용자 인터페이스의 이벤트를 관리할 스레드를 생성 / Timer : 대기 중인 작업을 실행할 스레드를 생성 등 / 서블릿, RMI : 스레드를 관리하는 풀을 여러 개 생성, 스레드를 사용해 컴포넌트의 메소드를 호출). 따라서 그런 스레드에서 호출되는 코드는 스레드에 대해 안전해야 하며, 더 세심하게 주의하고 분석해야 한다.
<br>

&nbsp;&nbsp;&nbsp;프레임워크 때문에 프로그램이 병렬로 실행되는 경우가 생기면 병렬로 실행된다는 사실을 프레임워크 뿐만 아니라 프로그램에서도 인식하고 적절히 대응해야 한다. 프레임워크 특성상 프로그램 컴포넌트의 기능을 호출해 결과를 받아오는 형태로 동작하는데, 이런 과정에서 필수적으로 프로그램 내부의 상태를 사용하기 때문이다. 
<br>

 &nbsp;&nbsp;&nbsp;아래의 편의 수단은 모두 프로그램이 관리하지 않는 외부의 스레드에서 프로그램 코드를 호출한다. <br>
+ 타이머 : <br>&nbsp;&nbsp;&nbsp;타이머는 추후에 한 번 혹은 주기적으로 실행될 작업을 스케줄하기 위한 편의 수단. Timer를 사용하면 TimerTask에 지정된 작업이 프로그램이 아닌 Timer가 관리하는 스레드에서 실행되기 때문에 순차적인 프로그램을 복잡하게 만들 수도 있다. TimerTask가 접근하는 객체 자체를 스레드 안전하게 만들어서 공유된 데이터 객체 내부에 스레드 안전성을 캡슐화 해준다.
+ 서블릿과 JSP : <br>&nbsp;&nbsp;&nbsp;서블릿 프레임워크는 웹 애플리케이션을 배치하고 원격 HTTP 클라이언트에서 오는 요청을 분배하기 위한 모든 기본 기능을 감당하도록 설계. 서블릿은 여러 스레드에서 동시에 호출될 수 있게 작성돼야 하며, 스레드에 안전해야 한다.
+ 원격 메서드 호출Remote Method Invocation : <br>&nbsp;&nbsp;&nbsp;RMI는 다른 JVM에서 실행 중인 객체의 메소드를 호출할 수 있게 해준다. RMI 코드가 원격 객체를 호출할 때는 RMI가 관리하는 스레드에서 호출된다. 
원격 객체는 스레드 안전성에 대해 두 가지 위험에 대비해야 한다. 다른 객체와 공유될 수 있는 상태에 접근할 때, 원격 객체 자체의 상태에 접근할때(같은 객체가 여러 스레드에서 동시에 호출될 수 있기 때문이다)이다.
+ 스윙과 AWT : <br>&nbsp;&nbsp;&nbsp;GUI 애플리케이션은 본질적으로 비동기적으로 동작한다. 사용자가 발생시킨 이벤트를 처리하거나 사용자가 보는 그래픽을 갱신하기 위해 별도 스레드를 생성해 작업을 맡긴다. <br>
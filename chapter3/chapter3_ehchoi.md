## 3장 객체 공유

### 목표
여러 개의 스레드에서 특정 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록 객체를 공유하고 공개하는 방법을 살펴보자.

<br/>
<br/>

## 3.1 가시성

소스코드의 특정 블록을 동기화시키고자 할 때는 항상 메모리 가시성 문제가 발생한다.
메모리 가시성 문제를 해결하기 위해서는 항상 특정 객체를 명시적으로 동기화 시키거나, 객체 내부에 적절한 동기화 기능을 내장시켜야 한다.

> 메모리 가시성 문제    
> Thread에서 변경한 특정 메모리의 값이, 다른 Thread에서 제대로 읽어지는가  

동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다.  
즉, 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 반드시 이런 순서로 동작할 것이라고 단정지을 수 없다는 것이다. (재배치 현상)

이런 상황들을 마주하지 않기 위해서는 **스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용하는 것** 이다.

<br/>

**동기화 구현 조건**  
- 특정 변수의 값을 사용하고 있을 때 다른 스레드가 해당 변수의 값을 사용하지 못하도록 막아야 한다.
- 이전 스레드가 값을 사용한 다음 동기화 블록을 빠져나가고 나면 다른 스레드가 변경된 값을 즉시 사용할 수 있게 해야 한다.

<br/>

**재배치 현상?**  
재배치 현상은 특정 메소드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제로 단일 스레드로 동작할 때는 차이점을 전혀 알아챌 수 없지만 여러 스레드가 동시에 동작하는 경우에는 확연하게 나타날 수 있다. 

<br/>

### 스테일 데이터

스테일 데이터란?  
한 프로세서가 피연산자의 값을 변경하고, 이어서 그 피연산자를 불러왔을 때 피연산자의 새로운 값이 아닌 변경되기 이전의 값을 가지고 왔다면, 그것을 스테일 데이터라고 한다.

변수를 사용하는 모든 경우에 동기화를 시켜두지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용하게 되는 경우가 발생할 수 있다.    
특정 스레드가 어떤 변수를 사용할 때 정상적인 최신 값을 사용할 ‘수'도 있고, 올바르지 않은 값을 사용할 ‘수'도 있다는 말이다.    
이는 데이터에 따라 안전에 심각한 문제를 유발하거나 프로그램이 멈추는 지경에 이를 수도 있다.

<br/>

 **스테일 현상 발생 시 일어날 수 있는 일**
- 예기치 못한 예외 상황 발생
- 데이터를 관리하는 자료구조가 망가짐
- 계산 결과 값이 올바르지 않을 수 있음
- 무한 반복에 빠짐

<br/>

동기화되지 않은 상태로 정수 값을 보관하는 클래스  
```
public class MutableInteger {

    private int value;

    public int get() {
        return value;
    }

    public void set(int value) {
        this.value = value;
    }
}

```

 <br/> 

동기화된 상태로 정수 값을 보관하는 클래스
```
public class SynchronizedInteger {
    private int value;

    public synchronized int get() {
        return value;
    }

    public synchronized void set(int value) {
        this.value = value;
    }
}

```

<br/>

### 단일하지 않은 64비트 연산

스케일 변수 값을 읽더라도 전혀 난데 없는 값이 생기지는 않는다. → 바로 이전에 다른 상태의 값을 읽어갈 뿐 엉뚱한 값을 가져가지는 않는다.  
하지만 64비트를 사용하는 숫자형(double이나 long 등)에 volatile 키워드를 사용하지 않은 경우에는 난데없는 값마저 생길 가능성이 있다.

자바 메모리 모델은 메모리에서 값을 가져오고 저장하는 연산이 단일해야 한다고 정의하고 있지만, volatile로 지정되지 않은 long이나 double형의 64비트 값에 대해서는 메모리에 쓰거나 읽을 때 두 번의 32비트 연산을 사용할 수 있도록 허용하고 있다. 따라서 volatile을 지정하지 않은 long변수의 값을 쓰는 기능과 읽는 기능이 서로 다른 스레드에서 동작한다면, 이전 값과 최신 값에서 각각 32비트를 읽어올 가능성이 생긴다.

<br/>

### 락과 가시성

synchronized를 사용 하면 스레드 A가 사용했던 모든 변수 값은, 같은 락을 사용하는 synchronized로 둘러싸인 코드를 스레드B가 실행할 때 안전하게 사용할 수 있다.   
값을 변경할 수 있는 변수를 여러 개의 스레드에서 동시에 사용한다면, 바로 이전 스레드에서 사용했던 변수의 값을 오류 없이 정상적으로 다음 스레드가 사용할 수 있게 하기 위한 동일한 락을 사용하는 synchronized블록으로 막아줄 필요가 있다.

여러 스레드에서 사용하는 변수를 적당한 락으로 막아주지 않는다면, 스테일 상태에 빠지기 쉽다.

락은 상호배제 뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용한다.   
변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야 한다.

 <br/> 

### volatile 변수

volatile로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다.  
컴파일러와 런타임 모두 '**이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안된다**'고 이해한다.  
volatile 지정된 변수는 프로세서의 레지스터에 캐시되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있다.  

<br/>

메모리 가시성의 입장에서 본다면 volatile 변수를 사용하는 것과 synchronized키워드로 특정 코드를 묶는게 비슷한 효과를 가져오고, volatile 변수의 값을 읽고 나면 synchronized 블록에 진입하는 것과 비슷한 상태에 해당한다.  
이처럼 volatile은 synchronized와 비슷한 형태로 작동하지만 **아무런 락이나 동기화 기능이 동작하지 않기 때문에** synchronized를 사용한 동기화보다는 아무래도 강도가 약할 수 밖에 없다. 

> volatile은 하나의 스레드에서만 사용한다는 보장이 없는 상태라면, volatile 연산자의 기본적인 능력으로는 증감 연산자를 사용한 부분까지 동기화를 맞춰 주지는 않는다.


<br/>
락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있지만 volatile변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.  
-> volatile변수에 너무 의존하지 않는 게 좋다.

<br/>

volatile변수 사용 여부의 결정
- 동기화하고자 하는 부분을 명확하게 볼 수 있고, 구현하기 훨씬 간단한 경우에만 volatile 변수를 활용하자.  
- 반대로 작은 부분이라도 가시성을 추론해봐야 하는 경우에는 volatile 변수를 사용하지 않는 것이 좋다.   


volatile 변수를 사용할 수 있는 상황  
- 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재
- 해당 변수가 객체의 불변조건을 이루는다른 변수와 달리 불변조건에 관련되어 있지 않다.
- 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우

일반적인 사용 경우 : 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트(초기화, 종료 등)가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우

<br/>
<br/>

## 3.2 공개와 유출

특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개되었다고 한다.
- 스코프 밖의 코드에서 볼 수 있는 변수에 스코프 내부의 객체에 대한 참조를 저장
- private이 아닌 메소드에서 호출한 메소드가 내부에서 생성한 객체를 리턴
- 다른 클래스의 메소드로 객체를 넘겨주는 경우 등

만약 클래스 내부의 상태 변수를 외부에 공개해야 한다면 객체 캡슐화 작업이 물거품이 되거나 내부 데이터의 안정성을 해칠 수 있다.  
따라서 객체가 안정적이지 않은 상태에서 공개하면 스레드 안전성에 문제가 생길 수 있다.  

<br/>  

객체가 공개되는 경우
```
public static Set<Secret> knownSecrets;

public void initialize(
) {
    knownSecrets = new HashSet<Secret>();
}
``` 
<br/>

관련된 다른 객체까지 덩달아 공개되는 경우
```
class UnsafeStates {
    private String[] states = new String[] {
            "AK", "AL"...
    };
    public String[] getStates(
 ) { return states;}
}

```

> String은 참조변수로 값이 아닌 주소값을 반환하여 참조하게 된다.

  

위처럼 의도적으로 공개시키지 않았지만 외부에서 사용할 수 있게 공개된 경우를 유출 상태라고 한다.  
객체를 공개하면 private이 아닌 모든 변수 속성에 연결되어 있는 모든 객체가 함께 공개된다.   
객체를 공개했을 때 그 객체 내부의 private이 아닌 변수나 메소드를 통해 불러올 수 있는 모든 객체는 함께 공개된다는 점을 알아두자.

### 에일리언 메소드
에일리언 메소드 : 클래스에 정의는 되어 있지만 그 기능이 만들어져 있지 않은 메소드  

클래스를 상속받으면 오버라이드 한 에일리언 메소드의 내부를 누가 어떻게 구현할지 정확하게 알 수 없는 상황이기 때문에, 객체를 인자로 넘겨 받은 에일리언 메소드에서 넘겨 받은 객체를 다른 스레드에서 사용할 수 있도록 공개하지 않으리라는 보장이 없다.

**어떤 객체건 일단 유출되고 나면 다른 스레드가 유출된 클래스를 의도적이건 의도적이지 않건 간에 반드시 잘못 사용할 수 있다고 가정해야 한다.**

다른 스레드에서 공개된 객체를 사용해 실제로 어떤 작업을 하지 않기 때문에 별 문제가 아니라고 생각할 수도 있겠지만, 항상 누군가는 의도했건 의도하지 않았건 공개된 객체를 잘못 사용할 가능성에 노출되는 셈이다.  
→ 객체 내부에서 사용하는 값을 적절하게 캡슐화 해줘야 한다.

캡슐화 되었을 때 장점
- 프로그램이 정상적으로 동작할 것이라고 쉽게 예측할 수 있다.
- 예상치 못한 상황에서 원래 설계했던 동작을 벗어나지 않도록 제한할 수 있다.

<br/>

**생성 메소드를 실행하는 도중에는 this 변수가 외부에 유출되지 않게 해야한다.**

생성 메소드에서 this변수를 유출시키는 가장 흔한 오류는 생성 메소드에서 스레드를 새로 만들어 시작시키는 일이다.   
생성 메소드에서 또 다른 스레들르 만들어 내면 대부분의 경우에는 생성 메소드의 클래스와 새로운 스레드가 this 변수를 직접 공유하거나 자동으로 공유되기도 한다.  
필요한 기능이 있다면 생성 메소드에서 스레드를 ‘생성'하는건 별 문제가 없는 일이지만, 스레드를 생성과 동시에 ‘시작'시키는 건 문제의 소지가 많은 일이다.   
스레드를 생성하면서 바로 시작시키기 보다는 스레드를 시작시키는 기능을 start나 initializae 등의 메소드로 만들어 사용하는 편이 좋다.

```
public class TestService {

    public void startTestRunnable() {
        TestRunnable tr = new TestRunnable("Hello!");

        tr.run();
    }


    private class TestRunnable implements Runnable {

        private String message;

        public TestRunnable(String message) {
            this.message = message;
            //절대 생성자에서 실행시키지 말자
        }


        @Override
        public void run() {
            System.out.println(message);
        }
    }
}

```

<br/>

생성 메소드에서 오버라이드 가능한 다른 메소드(private도 아니고 final도 아닌)를 호출하는 경우가 있다면 this참조가 외부에 유출될 가능성이 있다.

this 클래스에 대한 참조를 외부에 공개하는 상황
```
public class ThisEscape {
    public ThisEscape (EventSource source) {
        source.registerListner(
                new EventListener() {
                    public void onEvent(Event e) {
                        doSomething(e);
                    }
                });
    }
}
```
<br/>

생성 메소드에서 this변수가 외부로 유출되지 않도록 팩토리 메소드를 사용하는 모습
```
public class SafeListener {
    private final EventListener listener;

    private safeListener(
) {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        };
    }

    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListner(safe.listener);
        return safe;
    }
}
```

<br/>
<br/>

## 3.3 스레드 한정

변경 가능한 객체를 공유해 사용하는 경우에는 항상 동기화 시켜야하지만 특정 객체를 단일 스레드에서만 활용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없다.   
→ 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안전성을 확보할 수 있다.

언어적인 차원에서 특정 변수를 대상으로 락을 걸 수 있는 기능을 제공하지 않는 것처럼, 임의의 객체를 특정 스레드에 한정시키는 기능도 제공하지 않는다.   
특정 모듈의 기능을 단일 스레드로 동작하도록 구현한다면, 언어적인 지원 없이 직접 구현한 스레드 한정 기법에서 나타날 수 있는 오류의 가능성을 최소화 할 수 있다.

경쟁조건을 막기 위해 ‘변경' 작업은 특정 스레드 한 곳에서만 할 수 있도록 제한해야 하고,   
읽기 작업이 가능한 다른 모든 스레드는 volatile변수의 특성상 가장 최근에 업데이트된값을 정확하게 읽어갈 수 있다.

<br/>

### 스택 한정
스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법이라고 할 수 있다. 

변수를 클래스 내부에 숨겨두면 변경 상태를 관리하기 쉬우며 클래스 내부에 숨겨둔 변수의 특정 스레드에 쉽게 한정시킬 수 도 있다.

 <br/> 

#### 로컬변수의 사용

로컬 변수는 모두 암묵적으로 현재 실행주인 스레드에 한정되어 있다고 볼 수 있는 이유
- 로컬 변수는 현재 실행 중인 스래드 내부의 스택에만 존재하기 때문이며, 스레드내부의 스택은 외부 스레드에서 물론 볼 수 없다.
- 스레드에 안전하지 않은 객체라고 해도 특정 스레드 내부에서만 사용한다면 동기화 문제가 없기 때문에 안전하다.

해당 객체를 현재 스레드에 한정해야 한다는 요구사항과 해당 객체가 스레드에 안전하지 않다는 점을 명확하게 정리해서 누구든 알아볼 수 있도록 표시해 두는 것이 좋다.  

<br/> 

#### ThreadLocal

스레드 로컬 변수는 변경 가능한 싱글턴이나 전역 변수 등을 기반으로 설계되어 있는 구조에서 변수가 임의로 공유되는 상황을 막기 위해 사용하는 경우가 많다.  
ThreadLocal 변수를 선언하면 멀티 스레드 환경에서 각 스레드마다 독립적인 변수를 가지고, get(), set() 메소드를 통해 값에 대해 접근할 수 있다.   

만약 원래 단일 스래드에서 동작하던 기능을 멀티스레드 환경으로 구성해야 할 때, 그 의미에 따라 다르지만 공유된 전역 변수를 ThreaadLocal을 활용하도록 변경하면 스레드 안전성을 보장할 수 있다.   
단일 스레드 애플리케이션에서 프로그램 전체를 대상으로 사용하던 캐시를 멀티스레드 애플리케이션에서는 여러 개 쓰레드별 캐시로 나눠 사용하는 편이 더 효과적일 것이다.

스레드 단위로 트랜잭션 컨텍스트를 관리하고자 할 때는 static으로 선언된 ThreadLocal변수에 트랜잭션 컨텍스트를 넣어두면 편리하다.   
만약 프레임웍에서 현재 진행 중인 트랜잭션이 어느 것인지 확인하고 싶다면 트랜잭션이 보관되어있는 ThreadLocal 클래스에서 쉽게 찾아낼 수 있다. 

ThreadLocal의 단점
- 메소드를 호출할 때마다 현재 실행 중인 스레드의 정보를 넘겨줘야 할 필요는 없지만, 이런 방법을 사용하는 코드는 해당 프레임웍에 대한 의존성을 갖게된다.
- 전역변수가 아니면서도 전역변수처럼 동작하기 때문에 프로그램 구조상 전역 변수를 남발하는 결과를 가져올 수도 있고, 따라서 메소드에 당연히 인자로넘겨야 할 값을 ThreadLocal을 통해 뒤로 넘겨주는 방법을 사용하면서 프로그램의 구조가 허약해질 가능성도 높다.
- 전역변수가 갖는 단점처럼  재사용성을 크게 떨어트릴 수 있고, 객체 간에 눈에 보이지 않는 연결 관계를 만들어내기 쉽다.  

→ 애플리케이션에 어떤 영향을 미치는지 정확하게 알고 신경 써서 사용해야 한다.  

  <br/>
  <br/>

## 3.4 불변성 

불변 객체는 맨 처음 생성되는 시점을 제외하고는 그 값이 전혀 바뀌지 않는 객체를 말한다.  
따라서 불변 객체는 그 태생부터 언제라도 스레드에 안전한 상태이다.


불변 객체
- 생성되고 난 이후에는 객체의 상태를 변경할 수 없다.
- 내부의 모든 변수는 final로 설정돼야 한다.
- 적절한 방법으로 생성돼야 한다. (this변수에 대한 참조가 외부로 유출되지 않아야 한다.)

**‘객체'가 불변이라는 것과 ‘참조'가 불변이라는 것은 반드시 구분해서 생각해야 한다.**  
불변객체가 가르키고 있는 참조 변수에 또 다른 불변 객체를 바꿔치기 하면 프로그램의 데이터가 언제든 바뀌는 셈이다.

<br/>

### final 변수

final키워드를 적절하게 사용하면 **초기화 안전성을 보장**하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있다.  완전한 불변 객체는 아니지만 상태 값이 하나 또는 두 개 정도로 바뀔 수 있는 거의 불변인 객체 역시 일반 객체보다는 **훨씬 고려해야 할 범위를 줄여준다.**  
그리고 변수를 final로 선언해두면 **후임자가 코드를 읽을 때에도 해당 변수에 지정된 값이 변하지 않는다는 점을 정확하게 이해할 수 있다.**

서로 관련되어 있는 여러 개의 변수 값을 서로 읽거나 쓰는 과정에 경쟁 조건이 발생할 수 있는데, 불변 객체에 해당하는 변수를 모두 모아두면 경쟁 조건을 방지할 수 있다. 

여러 개의 변수를 묶어 사용하고자 할 때, 불변 객체가 아닌 일반 객체를 만들어 사용하면 락을 사용해야 연산의 단일성을 보장할 수 있다.   
하지만 불변 객체에 변수를 묶어두면 특정 스레드가 불변 객체를 사용할 때 다른 스레드가 불변 객체 값을 변경하지 않을까 걱정하지 않아도 된다.   
만약 불변 객체 내부에 들어 있는 변수 값을 변경하면 새로운 불변 객체가 만들어지기 때문에, 기존에 변수 값이 변경되기 전의 불변 객체를 사용하는 다른 스레드는 아무른 이상 없이 계속 동작한다.


<br/>
<br/>

## 3.5 안전 공개

상황에 따라 객체를 숨기기만 해서는 프로그램을 제대로 작성할 수 없을 것이고 여러 스레드에서 공유하도록 공개해야 할 상황일 수 있는데, 이럴 때는 반드시 안전한 방법을 사용해야 한다.

객체를 올바르지 않게 공개하면 발생할 수 있는 두가지 문제
- 공개된 변수에 스테일 상태가 발생할 수 있는데, 해당 변수에 값을 지정한 후에도 null값이 지정되어 있거나 예전에 사용하던 참조가 들어가 있을 수도 있다.
- 다른 스레드는 모두 해당 변수에서 정상적인 참조 값을 가져갈 수 있지만 해당 클래의 입장에서는 스테일 상태에 빠질 수 있다.

<br/>

**특정 데이터를 여러 개의 스레드에서 사용하도록 공유할 때 적절한 동기화 방법을 적용하지 않는다면 굉장히 이상한 일이 발생할 가능성이 높다.**   

자바 메모리 모델에는 불변 객체를 공유하고자 할 때 초기화 작업을 안전하게 처리할 수 있는 방법이 만들어져 있다.   
반면에 불변 객체를 사용하면 객체의 참조를 외부에 공개할 때 추가적인 동기화 방법을 사용하지 않았다 해도 항상 안전하게 올바른 참조 값을 사용할 수 있다. 

<br/>

불변 객체의 요구 조건 
- 상태를 변경할 수 없어야 한다.
- 모든 필드의 값이 final로 선언돼야 한다.
- 적잘한 방법으로 생산해야 한다.

불변 객체는 별다른 동기화 방법을 적용하지 않았다 해도 어느 스레드에서든 마음껏 안전하게 사용할 수 있다. 불변 객체를 공개하는 부분에 동기화 처리를 하지 않았다 해도 아무런 문제가 없다.

<br/>

안전한 공개 방법의 특성  
불변 객체가 아닌 객체는 모두 올바른 방법으로 안전하게 공개해야 하며, 대부분은 공개하는 스레드와 불러다 사용하는 스레드 양쪽 모두에 동기화 방법을 적용해야 한다.
객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부의 스레드에게 동시에 볼 수 있어야 한다. 

올바르게 생성 메소드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개할 수 있다.
- 객체에 대한 참조를 static메소드에서 초기화시킨다.
- 객체에 대한 참조를 volatile 변수 또는 AtomicReference클래스에 보관한다.
- 객체에 대한 참조를 올바르게 생성된 클래스 내부의 final변수에 보관한다.
- 락을 사용해 올바르게 막혀  있는 변수에 객체에 대한 참조를 보관한다.

<br/>

**스레드 동기화를 위해 자바에서 기본으로 제공하는 것들**
- Hashtable, ConcurrentMap, synchronizedMap을 사용해 만든 Map 객체를 사용하면 그 안에 보관하고 있는 키와 값 모두를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.
- 객체를 Vector, CopyOnWriteArrayList, CopyOnWriteArraySet이나 synchronizedList 또는 synchronizedSet메소드로 만든 컬렉션은 그 안에 보관하고 있는 객체를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.
- BlockingQueue나 ConcurrentLinkedQueue컬렉션에 들어 있는 객체는 어느 스레드라도 항상 안전하게 사용할 수 있다.

<br/>

다음과 같이 static변수를 선언할 때 직접 new 연산자로 생성 메소드를 실행해 객체를 생성할 수 있다면 가장 쉬우면서도 안전한 객체 공개 방법이다
`public static Holder holder = new Holder(42);` 

> 안전하게 공개한 결과적인 불변 객체는 별 다른 동기화 작업 없이도 여러 스레드에서 안전하게 호출해서 사용할 수 있다.

<br/> 

### 가변 객체

객체의 생성 메소드를 실행한 이후에 그 내용이 변경될 수 있다면, 안전하게 공개했다 하더라도 그저 공개한 상태를 다른 스레드가 볼 수 있다는 정도만 보장할 수 있다.   
가변 객체를 사용할 때에는 **공개하는 부분과 가변 객체를 사용하는 모든 부분에서 동기화 코드를 작성해야만 한다.**
<br/>

가변성에 따라 객체를 공개할 때 필요한 점
- 불변 객체는 어떤 방법으로 공개해도 아무 문제가 없다.
- 결과적으로 불변인 객체는 안전하게 공개해야 한다.
- 가변 객체는 안전하게 공개해야 하고, 스레드에 안전하게 만들거나 락으로 동기화시켜야 한다.

<br/>

언제든 객체에 대한 참조를 가져다 사용하는 부분이 있다면, 그 객체로 어느 정도의 일을 할 수 있는지를 정확하게 알고 있어야 한다.
- 객체를 사용하기 전에 동기화 코드를 적용해 락을확보해야 하는가?
- 객체 내부의 값을 바꿔도 괜찮은가?
- 값을 읽기만 해야하는가?

<br/>
<br/>

여러 스레드를 동시에 사용하는 병렬 프로그램에서 객체를 공유해 사용하고자 할 때 가장 많이 사용되는 몇 가지 원칙을 살펴보면 다음과 같다.  

- 스레드 한정  
    스레드에 한정된 객체는 완전하게 해당 스레드 내부에 존재하면서 그 스레드에서만 호출해 사용할 수 있다.
- 읽기 전용 객체 공유  
    읽기 전용 객체를 공유해 사용한다면 동기화 작업을 하지 않더라도 여러 스레드에서 언제든지 마음껏 값을 읽어 사용할 수 있다. 물론 읽기 전용이기 때문에 값이 변경될 수는 없다. 불변 객체와 결과적으로 불변인 객체가 읽기 전용 객체에 해당 한다고 볼 수 있다.
- 스레드에 안전한 객체 공유  
    스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경 쓸 필요가 없고, 여러 스레드에서 마음껏 호출해 사용할 수 있다.
- 동기화 방법 적용  
    특정 객체에 동기화 방법을 적용해두면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없다. 스레드에 안전한 객체 내부에서 사용하는 객체나 공개된 객체 가운데 특정 락을 확보해야 사용할 수 있도록 막혀있는 객체 등에 동기화 방법이 적용되어 있다고 볼 수 있다.